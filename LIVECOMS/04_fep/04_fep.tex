%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%.  WRITE YOUR CHAPTER CONTENTS BELOW.  %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Introduction}


Computational chemists can support structure-activity relationship
studies in medicinal chemistry by making computer models that can
predict binding affinity of ligands to proteins. One of the most popular
techniques for this is Free Energy Perturbation (FEP), which relies on
simulation alchemical transformations of ligands in a congeneric series,
simulating them both in a protein target and in just a waterbox.
Relative free energies of binding ($\Delta\Delta$G in kcal/mol) can then be computed
by simply subtracting the $\Delta$G (in protein) and the $\Delta$G (in water). Some
introductory reading is recommended. \cite{mey2020best, cournia_allen_sherman_2017, kuhn_firth-clark_tosco_mey_mackey_michel_2020}

This tutorial will outline the steps needed to:

\begin{itemize}
\item
  Select a series of transformations to simulate using LOMAP
\item
  Use BioSimSpace to set up files needed for a standard FEP run in both
  SOMD and GROMACS
\item
  Run FEP using BioSimSpace on a computing cluster
\item
  Process FEP simulation results
\item
  Compile all FEP results locally and perform data analyses
\end{itemize}

For this tutorial we will be using TYK2, a common benchmarking set in
the FEP field, first used by SchrÃ¶dinger in their
\href{https://pubs.acs.org/doi/abs/10.1021/ja512751q}{2015 FEP+ paper}.

\begin{figure}[htp]
\includegraphics[width=\linewidth]{04_fep/inputs/tut_imgs/tyk2_protlig.png}
\caption{Tyrosine kinase 2 (TYK2) structure with bound ligand
(ejm\_48).}
\label{tyk2_bound_fig}
\end{figure}


Typically in FEP the goal is to predict free energies of binding for a
collection of ligands (normally 10-20). Although methods exist (such as
absolute FEP) that can predict these energies directly (i.e. $\Delta$Gbind),
these are often complicated and computationally expensive. (relative)
FEP uses a basic rule in thermodynamics that dictates that, given a
thermodynamic cycle, the net energy must always be 0. FEP allows users
to compute the $\Delta\Delta$G of binding between two ligands through this mechanism
(see figure \ref{thermodynamic_cycle_fig}).

\begin{figure}[htp]
\includegraphics[width=\linewidth]{04_fep/inputs/tut_imgs/therm_cycle.png}
\caption{Thermodynamic cycle that allows FEP practicioners to
compute relative energies of binding. Because the difference between the
vertical legs equals the difference between the horizontal legs, we can
circumvent predicting $\Delta$G$_{bind}$ directly, but instead compute $\Delta\Delta$G$_{bind}$ by
transforming between two ligands in both the solvated and bound phase.}
\label{thermodynamic_cycle_fig}
\end{figure}

Because \emph{relative} energies are calculated, pairs of ligands have to be transformed into one another in both the fee and bound phase (hence the name free energy \emph{perturbation}. Typically, smaller (i.e. fewer heavy atoms) transformations are more reliable which means
that for a ligand series it is recommended to selectively make combinations of
ligands to cover the whole series. In FEP, this is done this using
\emph{perturbation networks}, typically generated by FEP softwares.
Although generating these networks can be done by hand, it is typically
better to do it programmatically to save time and create more optimal networks
(transformation reliability does not depend just on transformation size,
but also on a series of other unfavourable moiety transformations).

\subsubsection{Setting up a FEP calculation using BioSimSpace}

BioSimSpace allows users to set up and run a FEP calculation with just a
few lines of code (and input files). First, BioSimSpace is imported and
and input structures are read:

\begin{python}
import BioSimSpace as BSS
ligand_1 = BSS.IO.readMolecules("ligand_1.mol2")[0]
ligand_2 = BSS.IO.readMolecules("ligand_2.mol2")[0]
protein = BSS.IO.readMolecules("protein.pdb")[0]
\end{python}

\noindent Input molecules are parameterised using Amber-style force fields:

\begin{python}
ligand_1 = BSS.Parameters.gaff2(ligand_1).getMolecule()
ligand_2 = BSS.Parameters.gaff2(ligand_2).getMolecule()
protein = BSS.Parameters.ff14sb(protein).getMolecule()
\end{python}

\noindent We support a variety of other force fields as well. Because one ligand is transforming to the other, they need to be
well aligned. This can be done by:

\begin{python}
atom_mapping = BSS.Align.matchAtoms(ligand_1, ligand_2)
ligand_1 = BSS.Align.rmsdAlign(ligand_1, ligand_2, 
                                     atom_mapping)
\end{python}

\noindent Now a `merged' molecule (i.e. a molecule that we can
manipulate in a way such that the endpoints are either input ligands) has to be made. Adding this merged structure into the protein structure can be done simply by addition; the complete system can then be solvated.

\begin{python}
merged = BSS.Align.merge(ligand_1, ligand_2)
system = merged + protein
system_solvated = BSS.Solvent.tip3p(molecule=system, 
                box=3*[10*BSS.Units.Length.nanometer])
\end{python}

\noindent At which point all structures necessary for a FEP run are created. A FEP protocol can be set by:

\begin{python}
protocol = BSS.Protocol.FreeEnergy()
\end{python}

\noindent Note that calling no arguments sets the default FEP protocol. BioSimSpace can set up all necessary files by:

\begin{python}
freenrg_free = BSS.FreeEnergy.Relative(solvated, 
                        protocol, work_dir="output")
freenrg_bound = BSS.FreeEnergy.Relative(system_solvated, 
                        protocol, work_dir="output")
\end{python}

\noindent Running the free and bound FEP calculations is done by:

\begin{python}
freenrg_free.run() 
freenrg_bound.run() 
\end{python}
\noindent After simulations have finished we can retrieve the free energies and subtract them to get the relative binding free energy:
\begin{python}
pmf_bound, overlap_bound = freenrg_bound.analyse()
pmf_free,  overlap_free  = freenrg_free.analyse()

free_nrg_binding = \
BSS.FreeEnergy.Relative.difference(pmf_bound, pmf_free)
\end{python}

\noindent Note that this only makes sense on a workstation with GPUs or GPU cloud resources or a GPU cluster. If the code is run as above, each $\lambda$ window simulation is run sequentially which is not very efficient.

\subsubsection{Workflow of a BioSimSpace FEP pipeline}

Because a single FEP simulation typically takes hours to run on a
single GPU (depending on settings and hardware), FEP is usually run on a
computing cluster (or HPC/ cloud service). This allows practitioners to
run many simulations at the same time, turning an FEP pipeline into a
process that takes just several days (or even fewer) instead of weeks (or
even more).

Given a protein input file and a series of ligand input files, we will
be using a Jupyter Notebook that uses LOMAP to generate a perturbation
network for us. This notebook will also write all files necessary to
further prepare our FEP simulations. Because preparing ligands and
proteins for FEP can already require some heavy computation, this will
be the first process that will run on a cluster. Then, after running and
processing the FEP outputs, we can download the results back to our
local workstation. There, the analysis notebook uses FreeEnergyAnalysis
to process FEP predictions and generate plots.

\begin{figure}[htp]
\includegraphics[width=\linewidth]{04_fep/inputs/tut_imgs/fep_pipeline.png}
\caption{Schematic of the FEP pipeline in this tutorial. Whereas blue boxes
represent notebooks run on a local machine, orange boxes represent
python scripts run sequentially on a computing cluster.}
\label{fep_pipeline_fig}
\end{figure}


\subsubsection{Generating a perturbation network to run FEP on a congeneric series of ligands}

For this step, open the jupyter notebook \textbf{setup\_fep.ipynb}. If
you would like to use your own ligands and protein, you can put these in
\texttt{inputs/ligands/} and \texttt{inputs/protein/}, respectively.

After running all the cells in this notebook, the folder
\texttt{./execution\_model/} will contain everything needed to run FEP
in parallel on your cluster. To move this folder to your cluster, you
can use for instance SCP:

\begin{lstlisting}
$ scp -r execution_model uname@cluster.address:/path/to/folder
\end{lstlisting}

\noindent \emph{Note: if a computing cluster shares its file system with the local workstation the above step is not needed.}


\subsubsection{Running FEP on a computing cluster using
BioSimSpace}

The folder \texttt{./execution\_model/} contains several scripts and
folders, of which the most important are:

\begin{itemize}
\item
  \texttt{processFEP-slurm.sh} and \texttt{processFEP-lsf.sh}: running
  either of these scripts will submit all simulation jobs (depending on the
  cluster setup). Note that there are several parameters at the top of
  these scripts that have to be set (by e.g. a system administrator)
  that will inform BioSimSpace of all relevant paths to software
  dependencies and other important matters.
\item
  \texttt{./scripts/} contains all necessary scripts to run FEP with
  BioSimSpace. Advanced users can tweak more settings in these.
\end{itemize}

If everything has been set up correctly, running:

\begin{lstlisting}
$ bash processFEP-slurm.sh
\end{lstlisting}

will start the whole FEP job submission (for SLURM clusters). First, all systems will be
prepared, then run and then analysed (see figure \ref{fep_pipeline_fig}). When jobs finish, FEP predictions will be written to \texttt{./outputs/SOMD/summary.csv} (in case of SOMD
engine). Logfiles for seeing process outputs can be found in
\texttt{./logs/}. Additionally, perturbations that were simulated
successfully will have an \emph{overlap matrix} figure saved to
\texttt{./logs/} (in case of SOMD); these can be checked to check if perturbations were likely to be reliable per simulation leg. \cite{mey2020best}

For the final analysis, only \texttt{./outputs/SOMD/summary.csv} is required. Thus, this file has to be downloaded back to the local workstation; using SCP again (from the workstation, i.e. not logged into the cluster):

\begin{lstlisting}
$ scp uname@cluster.address:/path/to/folder\ /outputs/SOMD/summary.csv .
\end{lstlisting}


\subsubsection{Analysing FEP results}

For this step, open the jupyter notebook \textbf{analyse\_fep.ipynb}.
Running cells in this notebook will generate typical FEP figures
(barplots and scatterplots); if you have missing or failed
perturbations, the script should be able to work out an optimal
prediction (although at some point with enough missing FEP predictions,
ligands will of course be missing). If you happen to have experimental
affinity values, you can validate how accurate your FEP predictions are. See figure \ref{fep_barplot_fig} for an example barplot generated from \textbf{analyse\_fep.ipynb}. Note that even though we depict per-ligand binding affinities as $\Delta$G, strictly speaking these are still quantities of $\Delta\Delta$G because they are still relative binding free energies compared to a reference! The $\Delta$G notation in this way is just a commonly applied tactic to indicate that the plots are per-ligand instead of pairwise.

\begin{figure}[htp]
\includegraphics[width=\linewidth]{04_fep/inputs/tut_imgs/fep_barplot.png}
\caption{Example barplot depicting FEP results, generated with the analysis jupyter notebook included in this tutorial.}
\label{fep_barplot_fig}
\end{figure}



% %%%% YOU CAN USE THIS BLOCK FOR PYTHON:
% \begin{python}
% import numpy as np
    
% def incmatrix(genl1,genl2):
%     M = []
%     m = len(genl1)  # comment 
%     for i in m:
%         M.append(i)
    
%     return M
% \end{python}

% %%%% YOU CAN USE THIS BLOCK FOR BASH:
% \begin{lstlisting}
% $ command -arg1 -arg2 -arg3 -arg4 -arg5 -arg6 > output.file 2> err.file
% \end{lstlisting}

% %%%% YOU CAN USE THE SAME BLOCK FOR TEXT (e.g. STDOUT):
% \begin{lstlisting}[columns=flexible]
% this is an example of a message printed to StdOut!
% \end{lstlisting}

% %%%% FOR LARGE CHUNKS OF TEXTS, USE \scriptsize{} (OR EVEN \tiny{}) TO MAKE IT FIT THE COLUMNS
% {\scriptsize
% \begin{lstlisting}[columns=flexible]

% %VERSION  VERSION_STAMP = V0001.000  DATE = 06/30/15  11:44:23                  
% %FLAG TITLE                                                                     
% %FORMAT(20a4)                                                                   
% ACE                                                                             
% %FLAG POINTERS                                                                  
% %FORMAT(10I8)                                                                   
%     1912       9    1902       9      25      11      43      24       0       0
%     2619     633       9      11      24      13      21      20      10       1
%       0       0       0       0       0       0       0       1      10       0
%       0
% %FLAG ATOM_NAME                                                                 
% %FORMAT(20a4)                                                                   
% HH31CH3 HH32HH33C   O   N   H   CA  HA  CB  HB1 HB2 HB3 C   O   N   H   CH3 HH31
% HH32HH33O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  
% O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  
% H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   
% H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  
% O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  
% H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   
% H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2  O   H1  H2 
% \end{lstlisting}
% }
